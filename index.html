<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flashcards（ランダム）</title>
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="manifest.json">
  <style>
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;margin:0;background:#111;color:#eee}
    .wrap{max-width:860px;margin:0 auto;padding:16px}
    .card{background:#1b1b1b;border:1px solid #2a2a2a;border-radius:14px;padding:18px;min-height:180px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:12px 0;align-items:center}
    button{background:#2a2a2a;color:#eee;border:1px solid #3a3a3a;border-radius:10px;padding:10px 12px;cursor:pointer}
    button:hover{background:#333}
    input[type="file"]{color:#eee}
    .muted{color:#aaa;font-size:12px;line-height:1.5}
    .big{font-size:20px;line-height:1.35;white-space:pre-wrap}
    .sep{height:1px;background:#2a2a2a;margin:14px 0}
    .kpi{display:flex;gap:12px;flex-wrap:wrap}
    .pill{background:#222;border:1px solid #2f2f2f;border-radius:999px;padding:6px 10px;font-size:12px;color:#ddd}
    a{color:#9ad}
    .status{font-size:12px;color:#cfc;}
    .status.warn{color:#fc9;}
    .status.err{color:#f99;}
    code{background:#1a1a1a;border:1px solid #2a2a2a;padding:1px 6px;border-radius:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1 style="margin:6px 0 6px;">Flashcards（ランダム）</h1>
    <div class="muted" style="margin-bottom:6px;">
      生徒配布向け：<b>初回は自動でデッキを読み込みます</b>（CSVインポートは任意）。<br>
      データは端末内に保存されます。オフラインでも動作します（PWA）。
    </div>

    <div class="row">
      <span id="status" class="status">起動中…</span>
    </div>

    <div class="row">
      <button id="btnNext">次へ（ランダム）</button>
      <button id="btnReveal">答えを見る</button>
      <button id="btnShuffle">シャッフル（出題履歴リセット）</button>
      <button id="btnCopy">表裏をコピー</button>
    </div>

    <div class="kpi">
      <div class="pill">カード枚数：<span id="kCards">0</span></div>
      <div class="pill">今日見た枚数：<span id="kToday">0</span></div>
      <div class="pill">デッキ：<span id="kSource">-</span></div>
      <div class="pill">最終更新：<span id="kUpdated">-</span></div>
    </div>

    <div class="sep"></div>

    <div class="card">
      <div class="muted" id="pos">-</div>
      <div class="big" id="front" style="margin-top:10px;">読み込み中…</div>
      <div class="sep"></div>
      <div class="big" id="back" style="display:none;"></div>
    </div>

    <div class="sep"></div>

    <details>
      <summary>先生用：デッキ操作（任意）</summary>
      <div class="row" style="margin-top:10px;">
        <input id="file" type="file" accept=".csv,text/csv" />
        <button id="btnImport">CSVインポート（任意）</button>
        <button id="btnExport">現在のデッキをCSVで書き出し</button>
        <button id="btnResetDefault">既定デッキに戻す</button>
        <button id="btnResetAll">端末内データ初期化</button>
      </div>
      <div class="muted">
        CSV形式（推奨）：<code>front,back</code>（1行目ヘッダ）。<br>
        ※ヘッダ無しでも「1列目=front、2列目=back」として読み取ります。<br>
        ※生徒には通常この欄は触らせない運用が安定します。
      </div>
    </details>

    <div class="muted" style="margin-top:12px;">
      ヒント：スマホは「ホーム画面に追加」でアプリ風に使えます。
    </div>
  </div>

<script>
  // --- PWA register
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    });
  }

  // --- Constants / keys
  const DEFAULT_DECK_URL = "./deck_default.csv";
  const META_URL = "./deck_meta.json";

  const KEY_DECK = "fc_deck_v2";
  const KEY_STATE = "fc_state_v2";
  const KEY_UPDATED = "fc_updated_v2";
  const KEY_SOURCE = "fc_source_v2"; // "default" | "custom"
  const KEY_VERSION = "fc_deck_version_v2"; // meta.version when default

  // --- DOM
  const elFront = document.getElementById("front");
  const elBack  = document.getElementById("back");
  const elPos   = document.getElementById("pos");
  const elStatus= document.getElementById("status");

  const kCards  = document.getElementById("kCards");
  const kToday  = document.getElementById("kToday");
  const kUpdated= document.getElementById("kUpdated");
  const kSource = document.getElementById("kSource");

  // --- Minimal CSV parser (quoted fields, commas, CRLF)
  function parseCSV(text) {
    const rows = [];
    let i = 0, field = "", row = [], inQuotes = false;
    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += c; i++; continue;
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { row.push(field); field = ""; i++; continue; }
        if (c === '\n') { row.push(field); rows.push(row); row = []; field = ""; i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    row.push(field);
    if (row.length > 1 || row[0].trim() !== "") rows.push(row);
    return rows;
  }

  function toCSV(rows) {
    const esc = (s) => {
      s = String(s ?? "");
      const need = /[",\n\r]/.test(s);
      s = s.replace(/"/g, '""');
      return need ? `"${s}"` : s;
    };
    return rows.map(r => r.map(esc).join(",")).join("\n");
  }

  function setStatus(msg, level="ok") {
    elStatus.textContent = msg;
    elStatus.className = "status" + (level==="warn" ? " warn" : level==="err" ? " err" : "");
  }

  function loadDeck() {
    try { return JSON.parse(localStorage.getItem(KEY_DECK)) ?? []; }
    catch { return []; }
  }
  function saveDeck(deck) {
    localStorage.setItem(KEY_DECK, JSON.stringify(deck));
    localStorage.setItem(KEY_UPDATED, new Date().toISOString());
  }
  function loadState() {
    try {
      return JSON.parse(localStorage.getItem(KEY_STATE)) ?? {
        seenToday: 0,
        lastSeenDate: null,
        history: []
      };
    } catch {
      return { seenToday: 0, lastSeenDate: null, history: [] };
    }
  }
  function saveState(st) { localStorage.setItem(KEY_STATE, JSON.stringify(st)); }

  function getSource() { return localStorage.getItem(KEY_SOURCE) || "default"; }
  function setSource(s) { localStorage.setItem(KEY_SOURCE, s); }
  function getVersion() { return localStorage.getItem(KEY_VERSION) || ""; }
  function setVersion(v) { localStorage.setItem(KEY_VERSION, v || ""); }

  function todayKey() {
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
  }

  let deck = loadDeck();
  let state = loadState();
  let currentIndex = -1;

  function ensureTodayCounter() {
    const t = todayKey();
    if (state.lastSeenDate !== t) {
      state.lastSeenDate = t;
      state.seenToday = 0;
      saveState(state);
    }
  }

  function updateKPI() {
    ensureTodayCounter();
    kCards.textContent = String(deck.length);
    kToday.textContent = String(state.seenToday);
    const upd = localStorage.getItem(KEY_UPDATED);
    kUpdated.textContent = upd ? new Date(upd).toLocaleString() : "-";
    kSource.textContent = (getSource()==="custom") ? "カスタム" : "既定";
  }

  function showCard(i) {
    if (deck.length === 0) {
      elPos.textContent = "-";
      elFront.textContent = "デッキが空です（既定デッキの読み込みに失敗した可能性があります）";
      elBack.style.display = "none";
      elBack.textContent = "";
      return;
    }
    currentIndex = i;
    const c = deck[i];
    elPos.textContent = `#${i+1} / ${deck.length}`;
    elFront.textContent = c.front ?? "";
    elBack.textContent  = c.back ?? "";
    elBack.style.display = "none";
  }

  function nextRandom() {
    if (deck.length === 0) return;

    const maxTry = Math.min(80, deck.length * 2);
    let i = -1;
    for (let t = 0; t < maxTry; t++) {
      const cand = Math.floor(Math.random() * deck.length);
      if (cand === currentIndex) continue;
      if (deck.length >= 8 && state.history.includes(cand)) continue;
      i = cand; break;
    }
    if (i === -1) {
      state.history = [];
      i = Math.floor(Math.random() * deck.length);
    }

    state.history.push(i);
    if (state.history.length > Math.min(80, deck.length)) {
      state.history = state.history.slice(-Math.min(80, deck.length));
    }

    ensureTodayCounter();
    state.seenToday += 1;
    saveState(state);

    showCard(i);
    updateKPI();
  }

  function resetSessionHistory() {
    state.history = [];
    saveState(state);
  }

  function parseDeckFromCSV(text) {
    const rows = parseCSV(text);
    if (rows.length === 0) return [];

    // detect header
    const header = rows[0].map(s => String(s ?? "").trim().toLowerCase());
    let start = 0, idxFront = 0, idxBack = 1;

    const hFront = header.indexOf("front");
    const hBack  = header.indexOf("back");
    if (hFront >= 0 && hBack >= 0) {
      start = 1; idxFront = hFront; idxBack = hBack;
    }

    const out = [];
    for (let r = start; r < rows.length; r++) {
      const row = rows[r];
      const front = String(row[idxFront] ?? "").trim();
      const back  = String(row[idxBack]  ?? "").trim();
      if (!front && !back) continue;
      out.push({ front, back });
    }
    return out;
  }

  async function fetchJSON(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("fetch failed");
    return await res.json();
  }

  async function fetchText(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("fetch failed");
    return await res.text();
  }

  async function ensureDefaultDeckLoaded() {
    // 1) read meta (best-effort)
    let meta = null;
    try {
      meta = await fetchJSON(META_URL);
    } catch {
      // offline or blocked; continue
    }

    const source = getSource();
    const storedVersion = getVersion();
    const metaVersion = meta?.version || "";

    const needsInit = deck.length === 0;
    const canAutoUpdate = (source === "default");
    const needsUpdate = canAutoUpdate && metaVersion && storedVersion && (metaVersion !== storedVersion);

    if (!needsInit && !needsUpdate) {
      if (metaVersion && !storedVersion && source==="default") {
        // first time storing version even if deck exists
        setVersion(metaVersion);
      }
      return;
    }

    try {
      setStatus(needsInit ? "既定デッキを読み込み中…" : "既定デッキを更新中…", "warn");
      const csv = await fetchText(DEFAULT_DECK_URL);
      const newDeck = parseDeckFromCSV(csv);
      if (newDeck.length === 0) throw new Error("empty deck");

      deck = newDeck;
      saveDeck(deck);
      setSource("default");
      if (metaVersion) setVersion(metaVersion);
      updateKPI();
      showCard(0);
      setStatus(needsUpdate ? "既定デッキを更新しました" : "準備完了（既定デッキ）");
    } catch (e) {
      // fallback: keep existing deck if any
      if (deck.length) {
        setStatus("既定デッキの読み込みに失敗しました（端末内データで継続）", "warn");
      } else {
        setStatus("既定デッキの読み込みに失敗しました（オンライン接続を確認）", "err");
        showCard(-1);
      }
    }
  }

  // --- Buttons
  document.getElementById("btnReveal").onclick = () => {
    if (deck.length === 0) return;
    elBack.style.display = (elBack.style.display === "none") ? "block" : "none";
  };
  document.getElementById("btnNext").onclick = () => nextRandom();
  document.getElementById("btnShuffle").onclick = () => { resetSessionHistory(); nextRandom(); };

  document.getElementById("btnCopy").onclick = async () => {
    if (deck.length === 0) return;
    const c = deck[currentIndex >= 0 ? currentIndex : 0];
    const txt = `【表】${c.front ?? ""}\n【裏】${c.back ?? ""}`;
    try {
      await navigator.clipboard.writeText(txt);
      setStatus("コピーしました");
    } catch {
      setStatus("コピーできませんでした（ブラウザ権限）", "warn");
    }
  };

  document.getElementById("btnImport").onclick = async () => {
    const f = document.getElementById("file").files?.[0];
    if (!f) { alert("CSVファイルを選択してください"); return; }
    const text = await f.text();
    const newDeck = parseDeckFromCSV(text);
    if (newDeck.length === 0) { alert("カードが0件でした"); return; }

    deck = newDeck;
    saveDeck(deck);
    setSource("custom");
    setVersion(""); // custom deck isn't tied to meta
    state.history = [];
    saveState(state);

    updateKPI();
    showCard(0);
    setStatus(`インポート完了：${deck.length}枚（カスタム）`);
  };

  document.getElementById("btnExport").onclick = () => {
    if (deck.length === 0) { alert("デッキが空です"); return; }
    const rows = [["front","back"], ...deck.map(c => [c.front ?? "", c.back ?? ""])];
    const csv = toCSV(rows);
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "deck.csv";
    a.click();
    URL.revokeObjectURL(url);
  };

  document.getElementById("btnResetDefault").onclick = async () => {
    if (!confirm("既定デッキに戻します。よろしいですか？")) return;
    setSource("default");
    setVersion(""); // will be set after meta fetch
    deck = [];
    saveDeck(deck);
    state.history = [];
    saveState(state);
    updateKPI();
    await ensureDefaultDeckLoaded();
  };

  document.getElementById("btnResetAll").onclick = () => {
    if (!confirm("端末内のデッキと学習データを初期化します。よろしいですか？")) return;
    localStorage.removeItem(KEY_DECK);
    localStorage.removeItem(KEY_STATE);
    localStorage.removeItem(KEY_UPDATED);
    localStorage.removeItem(KEY_SOURCE);
    localStorage.removeItem(KEY_VERSION);
    deck = [];
    state = loadState();
    currentIndex = -1;
    updateKPI();
    showCard(-1);
    setStatus("初期化しました", "warn");
  };

  // --- Init
  (async () => {
    updateKPI();
    if (deck.length) {
      showCard(0);
      setStatus("準備完了（端末内データ）");
    } else {
      showCard(-1);
    }
    await ensureDefaultDeckLoaded();
    updateKPI();
    if (deck.length && currentIndex < 0) showCard(0);
    if (deck.length && currentIndex === 0) setStatus(getSource()==="custom" ? "準備完了（カスタム）" : "準備完了（既定デッキ）");
  })();
</script>
</body>
</html>
